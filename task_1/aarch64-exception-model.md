# Short Survey on the AArch64 Exception Model

## Introduction
In contemporary computers, various modules of the overall system must be executed with different privileges.
These include regular user programs, operating systems, and hypervisors.
The AArch64 architecture achieves this separation through the so-called Exception Levels.

## Exception Levels
Exception Levels (EL) form a hierarchy of privileges represented by EL0 through EL3.
EL0 is the lowest, and EL3 is the highest privilege level.
Access can be made from higher levels (e.g., EL3) to lower levels (e.g., EL2), but the reverse is not possible.

The architecture does not dictate which parts of the overall system must execute at a specific level.
However, typically, user processes run at EL0, the operating system at EL1, and the hypervisor at EL2.
EL3 is utilized by firmware and provides access to secure enclaves.

### Exception Level Transition
Exception Level transitions can occur only through the following methods:
- Occurrence of an exception
- Return from an exception
- Processor reset
- During debug mode
- Exiting debug mode

An exception occurrence can only lead to a transition to the same or a higher level.
Return from an exception can only transition to the same or a lower level.
However, EL0 can only trigger exceptions to a higher level, making EL0 the only level that cannot receive and handle exceptions.

## Execution States
Another concept in modern Arm processors is Execution States.
While not essential for understanding Exception Levels, they play a role later.

Execution States describe the different modes in which some ARM processors can operate.
There are two Execution States:
- AArch32
- AArch64

AArch32 is the 32-bit mode of the ARM architecture, backward compatible with older ARM architectures, capable of running, for example, (32-bit) ARMv7 applications.

AArch64 is the 64-bit mode of the ARM architecture and is not backward compatible with older ARM architectures.

Modern Arm processor architectures (as Armv8-A) can execute both 32-bit and 64-bit applications, switching between Execution States only through a reset or Exception Level change.

It's important to note:
- When transitioning from a lower to a higher EL, the Execution State can remain the same or switch to AArch64.
- When transitioning from a higher to a lower EL, the Execution State can remain the same or switch to AArch32.

Thus, an AArch32 layer at EL0 can be hosted by an AArch64 layer at EL1, but not vice versa.

## Exceptions
Exceptions are events that can occur during program execution.
They get classified into synchronous and asynchronous exceptions and can be further divided into various types.

### Synchronous Exceptions
Synchronous exceptions are triggered by the execution of an instruction, such as an invalid instruction or division by zero.
They are immediately handled as they arise during instruction execution.

AArch64 architecture utilizes synchronous exceptions to implement kernel or hypervisor calls through specific instructions that trigger an exception, subsequently handled by the operating system or hypervisor.

### Asynchronous Exceptions
Asynchronous exceptions are triggered by external events, like a timer generating an interrupt after a specific duration.
Interrupts in the AArch64 architecture are a form of asynchronous exceptions.

Through masking, asynchronous exceptions can be ignored until unmasked, useful in critical sections where interruptions by interrupts are undesired.

## Handling Exceptions
To respond to exceptions, the processor needs to know where to find the code to execute when an exception occurs.
Exception Vectors, stored in the Exception Vector Table, serve this purpose.

### Exception Vectors
An Exception Vector is responsible for handling a specific type of exception and contains the code to execute when that exception occurs.
Each Exception Type has its own vector, and it is 32 words (128 bytes) in size, sufficient for storing a branch instruction that jumps to the respective Exception Handler.

### Exception Vector Table
Exception Vectors are stored in an array called the Exception Vector Table, with the position in the array corresponding to the type of exception.
Each Exception Level has its own Exception Vector Table, with its memory position set by specific registers.

The Exception Vector Table includes entries for four different exception types:
- Synchronous (triggered by instruction execution)
- IRQ (asynchronous exceptions, triggered by external signals)
- FIQ (another asynchronous exceptions, triggered by external signals)
- SError (System Error generated by the memory system)

There are four entries for each type, differentiating:
- Exception from the current EL while using the EL0 stack pointer
- Exception from the current EL while using the stack pointer of the current EL
- Exception from a lower EL, with at least one lower EL in Execution State AArch64
- Exception from a lower EL, with all lower ELs in Execution State AArch32

Thus, there are 16 entries in the Exception Vector Table of each EL (excluding EL0 as it cannot receive exceptions).

### Exception Handler
The Exception Handler is responsible for handling an exception.

It is invoked by the Exception Vector and can rectify the error or terminate the program, typically after saving the processor status for later restoration.

Various registers containing information about the error are available to the Exception Handler.

After handling the error, the processor status is restored, and the program can continue.

## References
This brief overview serves as an introduction and does not cover all details.

For a more in-depth yet still relatively high-level overview, I recommend [this](https://developer.arm.com/documentation/102412/0103) source.